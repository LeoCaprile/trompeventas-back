// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: users.sql

package client

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createOAuthAccount = `-- name: CreateOAuthAccount :one
INSERT INTO oauth_accounts (user_id, provider, provider_user_id, access_token, refresh_token, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, created_at
`

type CreateOAuthAccountParams struct {
	UserID         uuid.UUID        `json:"user_id"`
	Provider       string           `json:"provider"`
	ProviderUserID string           `json:"provider_user_id"`
	AccessToken    pgtype.Text      `json:"access_token"`
	RefreshToken   pgtype.Text      `json:"refresh_token"`
	ExpiresAt      pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateOAuthAccount(ctx context.Context, arg CreateOAuthAccountParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, createOAuthAccount,
		arg.UserID,
		arg.Provider,
		arg.ProviderUserID,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (user_id, token_hash, expires_at)
VALUES ($1, $2, $3)
RETURNING id, user_id, token_hash, expires_at, created_at, revoked
`

type CreateRefreshTokenParams struct {
	UserID    uuid.UUID        `json:"user_id"`
	TokenHash string           `json:"token_hash"`
	ExpiresAt pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, createRefreshToken, arg.UserID, arg.TokenHash, arg.ExpiresAt)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Revoked,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, password_hash, name, email_verified, image)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, email, password_hash, name, email_verified, image, created_at, updated_at
`

type CreateUserParams struct {
	Email         string      `json:"email"`
	PasswordHash  pgtype.Text `json:"password_hash"`
	Name          string      `json:"name"`
	EmailVerified pgtype.Bool `json:"email_verified"`
	Image         pgtype.Text `json:"image"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.PasswordHash,
		arg.Name,
		arg.EmailVerified,
		arg.Image,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createVerificationToken = `-- name: CreateVerificationToken :one
INSERT INTO verification_tokens (user_id, token, type, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, token, type, expires_at, created_at
`

type CreateVerificationTokenParams struct {
	UserID    uuid.UUID        `json:"user_id"`
	Token     string           `json:"token"`
	Type      string           `json:"type"`
	ExpiresAt pgtype.Timestamp `json:"expires_at"`
}

func (q *Queries) CreateVerificationToken(ctx context.Context, arg CreateVerificationTokenParams) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, createVerificationToken,
		arg.UserID,
		arg.Token,
		arg.Type,
		arg.ExpiresAt,
	)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Type,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVerificationToken = `-- name: DeleteVerificationToken :exec
DELETE FROM verification_tokens WHERE token = $1
`

func (q *Queries) DeleteVerificationToken(ctx context.Context, token string) error {
	_, err := q.db.Exec(ctx, deleteVerificationToken, token)
	return err
}

const getOAuthAccount = `-- name: GetOAuthAccount :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, created_at FROM oauth_accounts WHERE provider = $1 AND provider_user_id = $2 LIMIT 1
`

type GetOAuthAccountParams struct {
	Provider       string `json:"provider"`
	ProviderUserID string `json:"provider_user_id"`
}

func (q *Queries) GetOAuthAccount(ctx context.Context, arg GetOAuthAccountParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccount, arg.Provider, arg.ProviderUserID)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getOAuthAccountByUserId = `-- name: GetOAuthAccountByUserId :one
SELECT id, user_id, provider, provider_user_id, access_token, refresh_token, expires_at, created_at FROM oauth_accounts WHERE user_id = $1 AND provider = $2 LIMIT 1
`

type GetOAuthAccountByUserIdParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Provider string    `json:"provider"`
}

func (q *Queries) GetOAuthAccountByUserId(ctx context.Context, arg GetOAuthAccountByUserIdParams) (OauthAccount, error) {
	row := q.db.QueryRow(ctx, getOAuthAccountByUserId, arg.UserID, arg.Provider)
	var i OauthAccount
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Provider,
		&i.ProviderUserID,
		&i.AccessToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT id, user_id, token_hash, expires_at, created_at, revoked FROM refresh_tokens WHERE token_hash = $1 AND revoked = FALSE AND expires_at > CURRENT_TIMESTAMP LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, tokenHash string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, tokenHash)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.Revoked,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, name, email_verified, image, created_at, updated_at FROM users WHERE email = $1 LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, password_hash, name, email_verified, image, created_at, updated_at FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserById(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Name,
		&i.EmailVerified,
		&i.Image,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getVerificationToken = `-- name: GetVerificationToken :one
SELECT id, user_id, token, type, expires_at, created_at FROM verification_tokens WHERE token = $1 AND expires_at > CURRENT_TIMESTAMP LIMIT 1
`

func (q *Queries) GetVerificationToken(ctx context.Context, token string) (VerificationToken, error) {
	row := q.db.QueryRow(ctx, getVerificationToken, token)
	var i VerificationToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.Type,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const revokeAllUserRefreshTokens = `-- name: RevokeAllUserRefreshTokens :exec
UPDATE refresh_tokens SET revoked = TRUE WHERE user_id = $1
`

func (q *Queries) RevokeAllUserRefreshTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllUserRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked = TRUE WHERE token_hash = $1
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, tokenHash)
	return err
}

const updateOAuthTokens = `-- name: UpdateOAuthTokens :exec
UPDATE oauth_accounts SET access_token = $1, refresh_token = $2, expires_at = $3 WHERE id = $4
`

type UpdateOAuthTokensParams struct {
	AccessToken  pgtype.Text      `json:"access_token"`
	RefreshToken pgtype.Text      `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamp `json:"expires_at"`
	ID           uuid.UUID        `json:"id"`
}

func (q *Queries) UpdateOAuthTokens(ctx context.Context, arg UpdateOAuthTokensParams) error {
	_, err := q.db.Exec(ctx, updateOAuthTokens,
		arg.AccessToken,
		arg.RefreshToken,
		arg.ExpiresAt,
		arg.ID,
	)
	return err
}

const updateUserEmailVerified = `-- name: UpdateUserEmailVerified :exec
UPDATE users SET email_verified = TRUE, updated_at = CURRENT_TIMESTAMP WHERE id = $1
`

func (q *Queries) UpdateUserEmailVerified(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateUserEmailVerified, id)
	return err
}

const updateUserImage = `-- name: UpdateUserImage :exec
UPDATE users SET image = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
`

type UpdateUserImageParams struct {
	Image pgtype.Text `json:"image"`
	ID    uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateUserImage(ctx context.Context, arg UpdateUserImageParams) error {
	_, err := q.db.Exec(ctx, updateUserImage, arg.Image, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = $1, updated_at = CURRENT_TIMESTAMP WHERE id = $2
`

type UpdateUserPasswordParams struct {
	PasswordHash pgtype.Text `json:"password_hash"`
	ID           uuid.UUID   `json:"id"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}
